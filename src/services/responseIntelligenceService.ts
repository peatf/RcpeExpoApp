/**
 * @file responseIntelligenceService.ts
 * @description Service for Generator Response Intelligence features.
 */

import {
  Response,
  ResponsePattern,
  SatisfactionMetrics,
  ResponseCorrelation,
  Exercise,
  ProgressMetrics,
  AuthorityType, // For mock data generation
} from '../types/humanDesignTools';

// Mock apiClient - replace with actual import from ./api when available
const apiClient = {
  post: async <T_Response, T_Request = any>(endpoint: string, payload: T_Request): Promise<{ data: T_Response }> => {
    console.log(`Mock API POST request to ${endpoint} with payload:`, payload);
    if (endpoint === '/api/v1/response/capture') {
      return new Promise((resolve) => setTimeout(() => resolve({ data: { success: true, responseId: `mock_resp_${Date.now()}`, insights: ['Response captured!'] } as any }), 500));
    }
    if (endpoint === '/api/v1/response/question-framing') {
      return new Promise((resolve) => setTimeout(() => resolve({ data: { reframedQuestions: ["Is this a 'hell yes'?", "Does thinking about this expand your energy?"], bestTiming: "When relaxed", environmentTips: ["Quiet space recommended"] } as any }), 500));
    }
    if (endpoint === '/api/v1/response/satisfaction-feedback') {
        return new Promise((resolve) => setTimeout(() => resolve({ data: { success: true, updatedInsights: ['Feedback noted, thanks!'] } as any }), 500));
    }
    return Promise.reject(new Error(`Unknown POST endpoint: ${endpoint}`));
  },
  get: async <T_Response>(endpoint: string, params?: any): Promise<{ data: T_Response }> => {
    console.log(`Mock API GET request to ${endpoint} with params:`, params);
    if (endpoint === '/api/v1/response/history') {
      const mockResponses: Response[] = [
        { id: 'r1', userId: 'u1', timestamp: new Date(Date.now() - 86400000).toISOString(), question: 'Go to event?', responseType: 'yes', responseStrength: 8, energy: { before: 6, after: 8, shift: 2 }, physical: { sensations: ['Warmth in belly'], locations: ['Belly'], intensity: 7 }, context: { category: 'Social', environment: 'Home', timeOfDay: 'Evening', importance: 6 }, distortion: { detected: false } },
        { id: 'r2', userId: 'u1', timestamp: new Date().toISOString(), question: 'New project?', responseType: 'no', responseStrength: 9, energy: { before: 7, after: 5, shift: -2 }, physical: { sensations: ['Contraction'], locations: ['Chest'], intensity: 8 }, context: { category: 'Work', environment: 'Office', timeOfDay: 'Morning', importance: 9 }, distortion: { detected: false } },
      ];
      const mockPatterns: ResponsePattern[] = [
        { id: 'rp1', description: 'Strong "yes" responses often correlate with increased energy.', confidence: 0.8, attributes: { responseTypes: ['yes'], categories: ['Social', 'Work'], timesOfDay: [], environments: [], physicalIndicators: ['Warmth'] }, metrics: { consistency: 0.9, satisfaction: 0.85, energyImpact: 1.5, distortionFrequency: 0.1 }, recommendations: ['Pay attention to warmth as a key indicator.'] }
      ];
      return new Promise((resolve) => setTimeout(() => resolve({ data: { responses: mockResponses, patterns: mockPatterns } as any }), 500));
    }
    if (endpoint === '/api/v1/response/satisfaction') {
      const mockMetrics: SatisfactionMetrics = { overall: 0.75, byResponseType: { 'yes': 0.8, 'no': 0.7 }, byResponseStrength: { '8': 0.85 }, byCategory: { 'Social': 0.8 }, byTimeOfDay: { 'Evening': 0.78 }, byEnvironment: { 'Home': 0.82 }, trend: { direction: 'improving', rate: 0.05 } };
      const mockCorrelations: ResponseCorrelation[] = [
        { factor: 'Response Strength > 7', correlationStrength: 0.7, confidence: 0.9, description: 'Higher strength responses strongly correlate with satisfaction.'}
      ];
      return new Promise((resolve) => setTimeout(() => resolve({ data: { satisfactionMetrics: mockMetrics, correlations: mockCorrelations } as any }), 500));
    }
    if (endpoint === '/api/v1/response/training') {
      const mockExercises: Exercise[] = [
        { id: 'ex1', title: 'Basic Response Tuning', description: 'Listen to simple yes/no questions.', steps: ['Relax.', 'Listen.', 'Feel response.'], purpose: 'Clarity', duration: 5, difficulty: 1, focus: 'clarity', completionMetric: 'Noted 5 responses' }
      ];
      const mockProgress: ProgressMetrics = { responseClarity: 0.6, satisfactionAlignment: 0.5, distortionAwareness: 0.4, completedExercises: 0, recommendedFocus: ['clarity'] };
      return new Promise((resolve) => setTimeout(() => resolve({ data: { exercises: mockExercises, progress: mockProgress } as any }), 500));
    }
    return Promise.reject(new Error(`Unknown GET endpoint: ${endpoint}`));
  },
};

/** @description Payload for capturing a sacral response, omitting fields generated by the backend. */
export type CaptureSacralResponsePayload = Omit<Response, 'id' | 'userId' | 'timestamp'>;

/** @description Filters for fetching response history. */
export interface GetResponseHistoryFilters {
  timeframe: string; // e.g., "7d", "30d", "all"
  responseType?: "yes" | "no" | "neutral" | "unclear";
  category?: string;
  strength?: string; // e.g., "high", "medium", "low" or "0-10"
}

/** @description Filters for fetching response satisfaction analytics. */
export interface GetResponseSatisfactionAnalyticsFilters {
  timeframe: string; // e.g., "30d", "90d", "all"
  includeUnrated: boolean;
}

/** @description Payload for getting question framing assistance. */
export interface GetQuestionFramingAssistancePayload {
  originalQuestion: string;
  context: string;
  importance: number; // e.g., 1-10
}

/** @description Filters for fetching response training exercises. */
export interface GetResponseTrainingExercisesFilters {
  focus: string; // e.g., "clarity", "strength", "differentiation"
  level: number; // e.g., 1-5 (beginner to advanced)
}

/** @description Payload for recording satisfaction feedback for a response. */
export interface RecordSatisfactionFeedbackPayload {
  responseId: string;
  satisfaction: number; // 0-10
  notes: string;
  outcomes: string[];
}

/**
 * Captures a sacral response.
 * @async
 * @param {CaptureSacralResponsePayload} payload - The response data.
 * @returns {Promise<{ success: boolean, responseId: string, insights?: string[] }>} Confirmation, ID, and potential initial insights.
 */
export const captureSacralResponse = async (
  payload: CaptureSacralResponsePayload
): Promise<{ success: boolean; responseId: string; insights?: string[] }> => {
  try {
    const response = await apiClient.post<
      { success: boolean; responseId: string; insights?: string[] },
      CaptureSacralResponsePayload
    >('/api/v1/response/capture', payload);
    return response.data;
  } catch (error) {
    console.error('Error capturing sacral response:', error);
    return { success: false, responseId: '', insights: [] };
  }
};

/**
 * Fetches response history with filtering.
 * @async
 * @param {GetResponseHistoryFilters} [filters] - Optional filters.
 * @returns {Promise<{ responses: Response[], patterns: ResponsePattern[] }>} List of responses and detected patterns.
 */
export const getResponseHistory = async (
  filters?: GetResponseHistoryFilters
): Promise<{ responses: Response[]; patterns: ResponsePattern[] }> => {
  try {
    const response = await apiClient.get<{ responses: Response[]; patterns: ResponsePattern[] }>(
      '/api/v1/response/history',
      { params: filters }
    );
    return response.data;
  } catch (error) {
    console.error('Error fetching response history:', error);
    return { responses: [], patterns: [] };
  }
};

/**
 * Fetches satisfaction analytics for responses.
 * @async
 * @param {GetResponseSatisfactionAnalyticsFilters} filters - Filters for the analytics.
 * @returns {Promise<{ satisfactionMetrics: SatisfactionMetrics | null, correlations: ResponseCorrelation[] }>} Satisfaction metrics and correlations.
 */
export const getResponseSatisfactionAnalytics = async (
  filters: GetResponseSatisfactionAnalyticsFilters
): Promise<{ satisfactionMetrics: SatisfactionMetrics | null; correlations: ResponseCorrelation[] }> => {
  try {
    const response = await apiClient.get<{ satisfactionMetrics: SatisfactionMetrics; correlations: ResponseCorrelation[] }>(
      '/api/v1/response/satisfaction',
      { params: filters }
    );
    return response.data;
  } catch (error) {
    console.error('Error fetching response satisfaction analytics:', error);
    return { satisfactionMetrics: null, correlations: [] };
  }
};

/**
 * Gets assistance for framing questions to the Sacral.
 * @async
 * @param {GetQuestionFramingAssistancePayload} payload - The original question and context.
 * @returns {Promise<{ reframedQuestions: string[], bestTiming: string, environmentTips: string[] }>} Suggestions for better questions.
 */
export const getQuestionFramingAssistance = async (
  payload: GetQuestionFramingAssistancePayload
): Promise<{ reframedQuestions: string[]; bestTiming: string; environmentTips: string[] }> => {
  try {
    const response = await apiClient.post<
      { reframedQuestions: string[]; bestTiming: string; environmentTips: string[] },
      GetQuestionFramingAssistancePayload
    >('/api/v1/response/question-framing', payload);
    return response.data;
  } catch (error) {
    console.error('Error getting question framing assistance:', error);
    return { reframedQuestions: [], bestTiming: '', environmentTips: [] };
  }
};

/**
 * Fetches personalized response training exercises.
 * @async
 * @param {GetResponseTrainingExercisesFilters} filters - Filters for the exercises.
 * @returns {Promise<{ exercises: Exercise[], progress: ProgressMetrics | null }>} Training exercises and user progress.
 */
export const getResponseTrainingExercises = async (
  filters: GetResponseTrainingExercisesFilters
): Promise<{ exercises: Exercise[]; progress: ProgressMetrics | null }> => {
  try {
    const response = await apiClient.get<{ exercises: Exercise[]; progress: ProgressMetrics }>(
      '/api/v1/response/training',
      { params: filters }
    );
    return response.data;
  } catch (error) {
    console.error('Error fetching response training exercises:', error);
    return { exercises: [], progress: null };
  }
};

/**
 * Records satisfaction feedback for a specific response-based decision.
 * @async
 * @param {RecordSatisfactionFeedbackPayload} payload - The satisfaction feedback.
 * @returns {Promise<{ success: boolean, updatedInsights: string[] }>} Confirmation and potential new insights.
 */
export const recordSatisfactionFeedback = async (
  payload: RecordSatisfactionFeedbackPayload
): Promise<{ success: boolean; updatedInsights: string[] }> => {
  try {
    const response = await apiClient.post< // Changed to POST as per typical REST for submitting data, even if backend uses PUT for this. Or align with doc if PUT is strict.
      { success: boolean; updatedInsights: string[] },
      RecordSatisfactionFeedbackPayload
    >('/api/v1/response/satisfaction-feedback', payload);
    return response.data;
  } catch (error) {
    console.error('Error recording satisfaction feedback:', error);
    return { success: false, updatedInsights: [] };
  }
};
