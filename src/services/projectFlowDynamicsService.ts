/**
 * @file projectFlowDynamicsService.ts
 * @description Service for Manifesting Generator Project Flow Dynamics.
 */

import {
  WorkflowSequence,
  WorkflowPattern,
  SkipStepPattern,
  FrustrationPoint,
  RhythmPattern,
  AuthorityType, // For mock data
} from '../types/humanDesignTools';

// Mock apiClient - replace with actual import from ./api when available
const apiClient = {
  post: async <T_Response, T_Request = any>(endpoint: string, payload: T_Request): Promise<{ data: T_Response }> => {
    console.log(`Mock API POST request to ${endpoint} with payload:`, payload);
    if (endpoint === '/api/v1/workflow/sequence') {
      return new Promise((resolve) => setTimeout(() => resolve({ data: { success: true, sequenceId: `mock_seq_${Date.now()}`, nextStepSuggestions: ['Review', 'Inform'] } as any }), 500));
    }
    if (endpoint === '/api/v1/workflow/frustration') {
      return new Promise((resolve) => setTimeout(() => resolve({ data: { success: true, similarPatterns: [{id: 'fp1', description: 'Similar block in past creative tasks'}], recommendations: ['Take a short break', 'Switch tasks'] } as any }), 500));
    }
    return Promise.reject(new Error(`Unknown POST endpoint: ${endpoint}`));
  },
  get: async <T_Response>(endpoint: string, params?: any): Promise<{ data: T_Response }> => {
    console.log(`Mock API GET request to ${endpoint} with params:`, params);
    if (endpoint === '/api/v1/workflow/patterns') {
      const mockPatterns: WorkflowPattern[] = [
        { id: 'wp1', description: 'Efficiently completes tasks by skipping initial planning for solo projects.', confidence: 0.8, projectTypes: ['solo creative'], steps: { sequence: ['ideate', 'execute', 'refine'], skipSteps: ['formal planning'], keyPoints: ['execution burst'] }, metrics: { completionRate: 0.9, averageSatisfaction: 8, frustrationRate: 0.1, energyEfficiency: 0.85 } },
      ];
      const mockFrustrationPoints: FrustrationPoint[] = []; // Empty for now
      return new Promise((resolve) => setTimeout(() => resolve({ data: { patterns: mockPatterns, insights: ['Skipping detailed planning works well for your solo work.'], frustrationPoints: mockFrustrationPoints } as any }), 500));
    }
    if (endpoint === '/api/v1/workflow/skip-steps') {
      const mockSkipPatterns: SkipStepPattern[] = [
        { id: 'ssp1', description: 'Skipping detailed documentation.', skippedStep: 'Documentation', projectTypes: ['internal tools'], effectiveness: 'positive', confidence: 0.9, impact: { timeImpact: 2, qualityImpact: 0, frustrationImpact: -1, collaborationImpact: -0.5 }, recommendedFor: ['Internal projects with clear scope'], cautionsFor: ['Client-facing projects'] },
      ];
      return new Promise((resolve) => setTimeout(() => resolve({ data: { skipStepPatterns: mockSkipPatterns, recommendations: ['Continue this for internal tools if team is aligned.'] } as any }), 500));
    }
    if (endpoint === '/api/v1/workflow/rhythm') {
        const mockRhythmPatterns: RhythmPattern[] = [
            { id: 'rp1', pattern: 'burst-pause-burst-complete', timeOfDay: ['morning', 'afternoon'], durationMinutes: { focus: 45, transition: 5, rest: 10 }, effectiveness: { energySustainability: 0.8, completionRate: 0.9, satisfactionLevel: 8 }, projectTypeMatch: { 'creative': 0.9, 'analytical': 0.7 } }
        ];
        return new Promise((resolve) => setTimeout(() => resolve({ data: { rhythmPatterns: mockRhythmPatterns, optimalSwitchTimes: ['Every 45-60 mins'], restPeriods: ['10 mins every hour'] } as any }), 500));
    }
    return Promise.reject(new Error(`Unknown GET endpoint: ${endpoint}`));
  },
};

/** @description Payload for recording a workflow sequence step. Excludes fields generated by backend. */
export type RecordSequenceStepPayload = Omit<WorkflowSequence, 'id' | 'userId' | 'timestamp'>;

/** @description Filters for fetching workflow patterns. */
export interface GetWorkflowPatternsFilters {
  timeframe: string;
  projectType?: string;
  includeSkipSteps?: boolean;
}

/** @description Filters for fetching skip step analytics. */
export interface GetSkipStepAnalyticsFilters {
  effectiveness?: "positive" | "negative" | "all";
  projectType?: string;
}

/** @description Payload for recording a frustration point. Excludes fields generated by backend or resolved after. */
export type RecordFrustrationPointPayload = Omit<FrustrationPoint, 'id' | 'timestamp' | 'resolution'>;

/** @description Filters for fetching personal workflow rhythm. */
export interface GetPersonalWorkflowRhythmFilters {
  resolution?: "day" | "week" | "hour";
}


/**
 * Records a step in a project workflow sequence.
 * @async
 * @param {RecordSequenceStepPayload} payload - The workflow sequence step data.
 * @returns {Promise<{ success: boolean, sequenceId: string, nextStepSuggestions?: string[] }>} Confirmation, ID, and potential next steps.
 */
export const recordSequenceStep = async (
  payload: RecordSequenceStepPayload
): Promise<{ success: boolean; sequenceId: string; nextStepSuggestions?: string[] }> => {
  try {
    const response = await apiClient.post<
      { success: boolean; sequenceId: string; nextStepSuggestions?: string[] },
      RecordSequenceStepPayload
    >('/api/v1/workflow/sequence', payload);
    return response.data;
  } catch (error) {
    console.error('Error recording sequence step:', error);
    return { success: false, sequenceId: '', nextStepSuggestions: [] };
  }
};

/**
 * Fetches workflow pattern analytics.
 * @async
 * @param {GetWorkflowPatternsFilters} [filters] - Optional filters.
 * @returns {Promise<{ patterns: WorkflowPattern[], insights: string[], frustrationPoints: FrustrationPoint[] }>} Workflow patterns, insights, and common frustration points.
 */
export const getWorkflowPatterns = async (
  filters?: GetWorkflowPatternsFilters
): Promise<{ patterns: WorkflowPattern[]; insights: string[]; frustrationPoints: FrustrationPoint[] }> => {
  try {
    const response = await apiClient.get<{ patterns: WorkflowPattern[]; insights: string[]; frustrationPoints: FrustrationPoint[] }>(
      '/api/v1/workflow/patterns',
      { params: filters }
    );
    return response.data;
  } catch (error) {
    console.error('Error fetching workflow patterns:', error);
    return { patterns: [], insights: [], frustrationPoints: [] };
  }
};

/**
 * Fetches analytics related to skip-step patterns.
 * @async
 * @param {GetSkipStepAnalyticsFilters} [filters] - Optional filters.
 * @returns {Promise<{ skipStepPatterns: SkipStepPattern[], recommendations: string[] }>} Skip-step patterns and recommendations.
 */
export const getSkipStepAnalytics = async (
  filters?: GetSkipStepAnalyticsFilters
): Promise<{ skipStepPatterns: SkipStepPattern[]; recommendations: string[] }> => {
  try {
    const response = await apiClient.get<{ skipStepPatterns: SkipStepPattern[]; recommendations: string[] }>(
      '/api/v1/workflow/skip-steps',
      { params: filters }
    );
    return response.data;
  } catch (error) {
    console.error('Error fetching skip step analytics:', error);
    return { skipStepPatterns: [], recommendations: [] };
  }
};

/**
 * Records a point of frustration in a project or workflow.
 * @async
 * @param {RecordFrustrationPointPayload} payload - The frustration point data.
 * @returns {Promise<{ success: boolean, similarPatterns?: any[], recommendations?: string[] }>} Confirmation and potential insights.
 */
export const recordFrustrationPoint = async (
  payload: RecordFrustrationPointPayload
): Promise<{ success: boolean; similarPatterns?: any[]; recommendations?: string[] }> => {
  try {
    const response = await apiClient.post<
      { success: boolean; similarPatterns?: any[]; recommendations?: string[] },
      RecordFrustrationPointPayload
    >('/api/v1/workflow/frustration', payload);
    return response.data;
  } catch (error) {
    console.error('Error recording frustration point:', error);
    return { success: false, similarPatterns: [], recommendations: [] };
  }
};

/**
 * Fetches the user's personal workflow rhythm patterns.
 * @async
 * @param {GetPersonalWorkflowRhythmFilters} [filters] - Optional filters.
 * @returns {Promise<{ rhythmPatterns: RhythmPattern[], optimalSwitchTimes: string[], restPeriods: string[] }>} Personal rhythm patterns and advice.
 */
export const getPersonalWorkflowRhythm = async (
  filters?: GetPersonalWorkflowRhythmFilters
): Promise<{ rhythmPatterns: RhythmPattern[]; optimalSwitchTimes: string[]; restPeriods: string[] }> => {
  try {
    const response = await apiClient.get<{ rhythmPatterns: RhythmPattern[]; optimalSwitchTimes: string[]; restPeriods: string[] }>(
      '/api/v1/workflow/rhythm',
      { params: filters }
    );
    return response.data;
  } catch (error) {
    console.error('Error fetching personal workflow rhythm:', error);
    return { rhythmPatterns: [], optimalSwitchTimes: [], restPeriods: [] };
  }
};
